#ifndef __DataStore_H_
#define __DataStore_H_

/*
    SQL DAL Maker Website: http://sqldalmaker.sourceforge.net
    About DataStore: http://sqldalmaker.sourceforge.net/xml-meta-programming.html
    Contact: sqldalmaker@gmail.com

    This is an example of how to implement DataStore in C++, SQLite C Library, and STL.
    Copy-paste this code to your project and change it for your needs.
*/

#include <string>
#include <vector>
#include <list>

enum ValueType
{
    VALUE_TYPE_LONG = 1,
    VALUE_TYPE_DOUBLE = 2,
    VALUE_TYPE_TEXT = 3,
    VALUE_TYPE_BLOB = 4
};

/*
CValue represents nullable values of columns and parameters.
Create inheritors and extend ValueType enum on demand.
Read also comments for type-map in 'setting.xml'.
*/
class CValue
{
public:

    bool IsNull;

    CValue(ValueType t)
    {
        type = t;
        IsNull = false;
    }

    ValueType getType()
    {
        return type;
    }

private:

    ValueType type;	 // C++ RTTI may be off
};

class CLong: public CValue
{
public:

    CLong() : CValue(VALUE_TYPE_LONG)
    {
        Value = 0;
    }

    int Value;
};

class CDouble: public CValue
{
public:

    CDouble() : CValue(VALUE_TYPE_DOUBLE)
    {
        Value = 0;
    }

    double Value;
};

class CText: public CValue
{
public:

    CText() : CValue(VALUE_TYPE_TEXT)
    {
    }

    std::string Value;
};

class CBlob: public CValue
{
public:

    CBlob() : CValue(VALUE_TYPE_BLOB)
    {
    }

    std::vector<unsigned char> Value;
};
/////////////////////////////////////////////////////

class CRowProcessor
{
public:

    virtual ~CRowProcessor() {}
    virtual void processRow() = 0;
};

/////////////////////////////////////////////////////

#define DL_STR const wchar_t *
#define DL_T(quote) L##quote

/////////////////////////////////////////////////////

class CDataStore
{
private:

    void * db;

    // Clear m_errors at beginning of each method.

    std::string errors;

public:

    std::string & getLastErrors()
    {
        return errors;
    }

    bool open();
    bool close();

    // TODO: add transaction management

    //////////////////////////////////////////
    //
    // The methods called from DAO classes generated by SQL DAL Maker:

    // if there are no AI_values (auto-increment), then call execDML instead
    // returns the number of inserted rows or -1 on error
    int insert(DL_STR sql, int params_count, CValue* params[], int AI_values_count, CValue* AI_values[]);

    // returns the number of updated rows or -1 on error
    int execDML(DL_STR sql, int params_count, CValue* params[]);

    // no params: params_count == 0 and params == 0
    // returns the number of fetched rows or -1 on error
    int queryRow(DL_STR sql, int params_count, CValue* params[], int ret_values_count, CValue* ret_values[], DL_STR col_names[]);

    // no params: params_count == 0 and params == 0
    // returns the number of fetched rows or -1 on error
    int queryRowList(DL_STR sql, int params_count, CValue* params[], int ret_values_count, CValue* ret_values[], DL_STR col_names[], CRowProcessor *rowProcessor);
};

/*

Usage of CListReader
--------------------

struct : CListReader<CCategory>
{
void read(CCategory &c)
{
_tprintf(_T("%ls\r\n"), c.CategoryName.m_value.GetBuffer());
}

} lr;

// getAllCategories is a method of generated DAO class

dao.getAllCategories(&lr);

*/

template <class T>
class CListReader
{
public:

    virtual ~CListReader() {}
    virtual void read(/*const*/ T &t) = 0;
};

/*

Usage of CListReader2
--------------------

CListReader2<CCategory> lr;

// getAllCategories is a method of generated DAO class

dao.getAllCategories(&lr);

_tprintf(_T("%d\r\n"), c.list.GetCount());

*/

template <class T>
class CListReader2 : public CListReader<T>
{
public:

    std::list<T> list;

    void read(T &t)
    {
        list.push_back(t);
    }
};


#endif //__DataStore_H_
