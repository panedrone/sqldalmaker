package com.sqldalmaker;

import com.mycom.myproject.dao.TestDao;
import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;

import java.io.StringWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/*
    SQL DAL Maker Website: http://sqldalmaker.sourceforge.net
    About DataStore: http://sqldalmaker.sourceforge.net/how-to-start.html
    Contact: sqldalmaker@gmail.com

    This is an example of how to implement DataStore in Java + Apache DbUtils.
    Copy-paste this code to your project and change it for your needs.
*/
public class DataStoreManager {

    private Connection connection;

    public void open() throws Exception {

        connection = DriverManager.getConnection("jdbc:mysql://localhost/sakila", "root", "root");
        connection.setAutoCommit(false);
    }

    public void commit() throws Exception {

        connection.commit();
    }

    public void rollback() throws Exception {

        connection.rollback();
    }

    public void close() throws Exception {

        // connection.setAutoCommit(true) is required for
        // org.apache.derby.jdbc.ClientDriver to prevent
        // java.sql.SQLException: Cannot close a connection while a transaction
        // is still active.

        connection.setAutoCommit(true);

        connection.close();
    }

    private final MyDataStore ds = new MyDataStore();

    // //////////////////////////////////////////////////
    //
    // MyDataStore is hidden, use factory method pattern:

    public TestDao createTestDao() {

        return new TestDao(ds);
    }

    private class MyDataStore extends DataStore {

        private boolean isStringValue(Class<?> inValueType) {
            // Consider any CharSequence (including StringBuffer and
            // StringBuilder) as a String.
            return (CharSequence.class.isAssignableFrom(inValueType)
                    || StringWriter.class.isAssignableFrom(inValueType));
        }

        private boolean isDateValue(Class<?> inValueType) {

            return (java.util.Date.class.isAssignableFrom(inValueType)
                    && !(java.sql.Date.class.isAssignableFrom(inValueType)
                    || java.sql.Time.class.isAssignableFrom(inValueType)
                    || java.sql.Timestamp.class.isAssignableFrom(inValueType)));
        }

        protected void prepareParams(Object... params) {

            for (int i = 0; i < params.length; i++) {

                if (params[i] != null) {

                    if (isStringValue(params[i].getClass())) {
                        params[i] = params[i].toString();
                    } else if (isDateValue(params[i].getClass())) {
                        params[i] = new java.sql.Timestamp(((java.util.Date) params[i]).getTime());
                    }
                }
            }
        }

        private boolean is_jdbc_stored_proc_call(String jdbc_sql) {

            jdbc_sql = jdbc_sql.trim();

            if (jdbc_sql.startsWith("{") == false || jdbc_sql.endsWith("}") == false) {
                return false;
            }

            // jdbc_sql = jdbc_sql.trim(); ^^ trimmed

            jdbc_sql = jdbc_sql.substring(1, jdbc_sql.length() - 1);

            String parts[] = jdbc_sql.split("\\s+");

            if (parts.length < 2) {
                return false;
            }

            String call = parts[0];

            return call.compareToIgnoreCase("call") == 0;
        }

        /**
         * MyQueryRunner
         * 1) allows to get generated keys after INSERT.
         * http://stackoverflow.com/questions/8705036/how-to-get-generated-keys-with-commons-dbutils
         * https://issues.apache.org/jira/browse/DBUTILS-54
         * 2) allows to call stored procedures that (optionally) obtain IN parameters and (optionally) return result set.
         * https://stackoverflow.com/questions/8742224/apache-dbutils-stored-procedure/8742300#8742300
         * https://javabob64.wordpress.com/2012/01/18/calling-a-stored-procedure-from-dbutils/
         */
        private class MyQueryRunner extends QueryRunner {

            public MyQueryRunner() {
                this(false);
            }

            public MyQueryRunner(boolean pmdKnownBroken) {
                super(pmdKnownBroken);
            }

            public <T> T queryCall(Connection conn, String sql, ResultSetHandler<T> rsh, Object... params)
                    throws SQLException {

                CallableStatement stmt = conn.prepareCall(sql);

                try {

                    super.fillStatement(stmt, params);

                    ResultSet rs = super.wrap(stmt.executeQuery());

                    return rsh.handle(rs);

                } catch (SQLException e) {

                    super.rethrow(e, sql, params);

                } finally {

                    DbUtils.close(stmt);
                }

                return null; // just to suppress compiler error
            }

            public int executeCall(Connection conn, String sql, Object... params)
                    throws SQLException {

                CallableStatement stmt = conn.prepareCall(sql);

                try {

                    super.fillStatement(stmt, params);

                    super.wrap(stmt.executeQuery());

                } catch (SQLException e) {

                    super.rethrow(e, sql, params);

                } finally {

                    DbUtils.close(stmt);
                }

                return 0;
            }

            public int insert(String sql, String[] genColNames, Object[] genValues, Object... params)
                    throws SQLException {

                PreparedStatement stmt = null;

                int rows = 0;

                try {

                    stmt = connection.prepareStatement(sql, genColNames);

                    super.fillStatement(stmt, params);

                    rows = stmt.executeUpdate();

                    doAfterInsert(stmt, genValues);

                } catch (SQLException e) {

                    super.rethrow(e, sql, params);

                } finally {

                    DbUtils.close(stmt);
                }

                return rows;
            }

            private void doAfterInsert(PreparedStatement stmt, Object[] genValues) throws SQLException {

                ResultSet keys = stmt.getGeneratedKeys();

                if (keys != null) {

                    try {

                        int i = 0;

                        while (keys.next()) {

                            // UNCOMMENT THE LINE WHICH IS WORKING WITH YOUR JDBC DRIVER

                            // keys.getBigDecimal(1) works with most of tested
                            // drivers (except SQLite)

                            Object obj = keys.getBigDecimal(1);

                            // keys.getObject(1) works with all tested drivers,
                            // but it can return Long for Integer column (MySQL)

                            // Object obj = keys.getObject(1);

                            genValues[i] = obj;

                            i++;
                        }

                    } finally {

                        DbUtils.close(keys);
                    }
                }
            }
        }

        @Override
        public <T> T castGeneratedValue(Class<T> type, Object obj) {

            // YOU CAN CHANGE/SIMPLIFY THIS METHOD IF IT IS POSSIBLE WITH YOUR JDBC DRIVER

            // For many drivers (SQL Server 2008, Derby), keys.getObject(1)
            // returns BigDecimal independently of type of column

            if (obj instanceof BigDecimal) {

                BigDecimal bigDecimal = (BigDecimal) obj;

                if (Byte.class.equals(type)) {

                    obj = bigDecimal.byteValueExact();

                } else if (Float.class.equals(type)) {
                    // there is no 'exact' version
                    obj = bigDecimal.floatValue();

                } else if (Double.class.equals(type)) {
                    // there is no 'exact' version
                    obj = bigDecimal.doubleValue();

                } else if (Integer.class.equals(type)) {

                    obj = bigDecimal.intValueExact();

                } else if (Long.class.equals(type)) {

                    obj = bigDecimal.longValueExact();

                } else if (BigInteger.class.equals(type)) {

                    obj = bigDecimal.toBigIntegerExact();

                } else if (BigDecimal.class.equals(type)) {

                    obj = bigDecimal;

                } else if (Object.class.equals(type)) {

                    obj = bigDecimal;

                } else {

                    throw new ClassCastException("Unexpected class '" + type.getName() + "'");
                }
            }

            // cast:

            // Throws:
            // ClassCastException - if the object is not null and is not
            // assignable
            // to the type T.

            return type.cast(obj);
        }

        @Override
        public int insert(String sql, String[] genColNames, Object[] genValues, Object... params) throws SQLException {

            prepareParams(params);

            MyQueryRunner queryRunner = new MyQueryRunner();

            return queryRunner.insert(sql, genColNames, genValues, params); // TODO: use in-bound QueryRunner.insert(...) instead
        }

        @Override
        public int execDML(String sql, Object... params) throws Exception {

            prepareParams(params);

            MyQueryRunner queryRunner = new MyQueryRunner();

            boolean sp = is_jdbc_stored_proc_call(sql);

            if (sp) {

                return queryRunner.executeCall(connection, sql, params);

            } else {

                return queryRunner.update(connection, sql, params);
            }
        }

        @Override
        public <T> T query(final Class<T> type, String sql, Object... params) throws Exception {

            ResultSetHandler<T> h = new ResultSetHandler<T>() {

                @Override
                public T handle(final ResultSet rs) throws SQLException {

                    if (!rs.next()) {

                        return null;
                    }

                    // the first column is 1

                    T res = type.cast(rs.getObject(1));

                    if (rs.next()) {

                        throw new SQLException("More than 1 row available");
                    }

                    return res;
                }
            };

            return query(sql, h, params);
        }

        @Override
        public <T> List<T> queryList(final Class<T> type, String sql, Object... params) throws Exception {

            final ArrayList<T> res = new ArrayList<T>();

            ResultSetHandler<Void> h = new ResultSetHandler<Void>() {

                @Override
                public Void handle(final ResultSet rs) throws SQLException {

                    while (rs.next()) {

                        // the first column is 1

                        T t = type.cast(rs.getObject(1));

                        res.add(t);
                    }

                    return null;
                }
            };

            query(sql, h, params);

            return res;
        }

        @Override
        public <T> T queryDto(String sql, final RowHandler<T> rowHandler, Object... params) throws Exception {

            ResultSetHandler<T> h = new ResultSetHandler<T>() {

                @Override
                public T handle(final ResultSet rs) throws SQLException {

                    if (!rs.next()) {

                        return null;
                    }

                    RowData vr = new RowData() {

                        public <V> V getValue(Class<V> type, String columnLabel) throws Exception {

                            return type.cast(rs.getObject(columnLabel));
                        }
                    };

                    T res;

                    try {

                        res = rowHandler.handleRow(vr);

                    } catch (Exception e) {

                        throw new SQLException(e);
                    }

                    if (rs.next()) {

                        throw new SQLException("More than 1 row available");
                    }

                    return res;
                }
            };

            return query(sql, h, params);
        }

        @Override
        public <T> List<T> queryDtoList(String sql, final RowHandler<T> rowHandler, Object... params) throws Exception {

            final ArrayList<T> res = new ArrayList<T>();

            ResultSetHandler<Void> h = new ResultSetHandler<Void>() {

                @Override
                public Void handle(final ResultSet rs) throws SQLException {

                    RowData vr = new RowData() {

                        public <V> V getValue(Class<V> type, String columnLabel) throws Exception {

                            return type.cast(rs.getObject(columnLabel));
                        }
                    };

                    while (rs.next()) {

                        try {

                            T t = rowHandler.handleRow(vr);

                            res.add(t);

                        } catch (Exception e) {

                            throw new SQLException(e);
                        }
                    }

                    return null;
                }
            };

            query(sql, h, params);

            return res;
        }

        private <T> T query(String sql, ResultSetHandler<T> rsh, Object... params) throws SQLException {

            MyQueryRunner queryRunner = new MyQueryRunner();

            prepareParams(params);

            boolean sp = is_jdbc_stored_proc_call(sql);

            if (sp) {

                return queryRunner.queryCall(connection, sql, rsh, params);

            } else {

                return queryRunner.query(connection, sql, rsh, params);
            }
        }
    }
}